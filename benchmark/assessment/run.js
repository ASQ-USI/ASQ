var mongoose=require('mongoose');
db = mongoose.createConnection('localhost', 'benchmark');

var gen = require('when/generator')
  , when = require('when')
  , models = require('../../models') // load all models
  , mongooseFixtures  = require('../util/mongoose-fixtures')
  , assManager =  require('../../lib/assessment/assessment')
  , Session = db.model('Session')
  , Exercise = db.model('Exercise')
  , Question = db.model('Question')
  , Answer = db.model('Answer')
  , WhitelistEntry = db.model('WhitelistEntry')
  , util = require('util')
  , mode="avg"
  , viewerNum = 100
  , jobCounters={}
  , totalCounter = 0
  , totalAssessments = viewerNum * (viewerNum -1)
  , lamda = viewerNum/2000;  //initial value


//process command line args:
var args = {};
process.argv.slice(2).forEach(function(clarg){
  var splitted = clarg.split("=");
  args[splitted[0]] = (1 in splitted)? splitted[1] : '' 
})

//check for --users=<number> argument
if("undefined" != typeof args['--users']){
  viewerNum= + args['--users']
}

//set variable affectes by arguments
totalAssessments = viewerNum * (viewerNum -1);
lamda = viewerNum/1000 //viewer submissions every 10 minutes

//check for --mode=<value> argument
// value= 'worst', 'avg'
if("undefined" != typeof args['--mode']){
  var value = args['--mode'];
  if(['worst', 'avg'].indexOf(value) >= 0) mode = value;
}

var fixtureObj = require('./fixtures')(viewerNum)
  , fixtures = fixtureObj.fixtures
  , questions = fixtureObj.questions
  , session = fixtureObj.session
  , exercise = fixtureObj.exercise
  , whitelist = fixtureObj.whitelist;


/**
* Generator function that starts a job. It updates and sets the status
* to active and enqueues a submitJob function call after a random time
* generated by sampling an exponential sampler
* @param {AssessmentJob} job The job to start
* @param {Exercise} exercise The exercise the job is for
* @param {WhitelistEntry} assessor Assessor of the assessment job
*/
function *startJobGen(job, exercise, assessor){
   if(! job){

    // console.log("No assessment #%d for assessor %s",
    //   jobCounters[assessor._id], assessor.screenName);

    return;
   }

   try{
    job.status = "active";
    yield job.save();
    
    // console.log("Assigned assessment #%d to user %s",
    // jobCounters[assessor._id] , assessor.screenName);

    setTimeout(submitJob, ~~expSample(lamda), job, exercise, assessor);
   }catch(err){
    console.log(err.stack)
   }        
}

var startJob = gen.lift(startJobGen);

/**
* Generator function that runs the benchmark
*/
function *runGen(){
  var result;
  try{
    // retrieve Mongoose session objects for session and exercise
    session = yield Session.findOne({_id: session._id}).exec();
    exercise = yield Exercise.findOne({_id: exercise._id}).exec();
    questions = yield Question.find({}).exec();

    var l = whitelist.length;
    
    for (var i=0; i<l; i++){
      //get random user
      var index = Math.floor(Math.random() * whitelist.length);
      var whitelistEntry = whitelist[index];
      whitelist.splice(index, 1);

      //create jobCounter entry
      jobCounters[whitelistEntry._id]=1;

      //create answers
      var answers=[];
      questions.forEach(function(question){
        answers.push({
          exercise : exercise._id,
          question : question._id,
          session: session._id,
          submission : ['basic-question-' + question._id + '-user-' + index],
          confidence : 3,
          answeree : whitelistEntry._id
        });
      });

      //persist to mongo
      answers = yield Answer.create(answers);

      //populate question field
      yield when.map(answers, gen.lift(function *populateQuestions(answer){
        yield answer.populate('question').execPopulate();
      }));
     
      var startAssessmentCreation = new Date;
      result = yield assManager.enqueue(session._id, exercise, answers)
      // console.log ( "Created assessments in %s ms for user %s",
      //  new Date - startAssessmentCreation, whitelistEntry.screenName );
      // console.log('after queue:Using %s of memory', bytesToSize(process.memoryUsage().heapUsed));

      /* ---------- ACTUAL BENCHMARK STARTS HERE ---------- */
      start = new Date;

      // find next assessment job for each of the viewers
      var nextJob = yield assManager.getNextAssessmentJob(session._id, exercise, whitelistEntry._id);

      console.log("Searched for assessment #%d in %d ms for \
user %d of %d %s",jobCounters[whitelistEntry._id], (new Date - start), i+1, l, whitelistEntry.screenName);

      yield startJob(nextJob, exercise, whitelistEntry);

      var nextJobs = yield assManager.getNextJobForIdleViewers(session._id, exercise);
      
      //start jobs for idle users in parallell, no need to wait with a yield
      when.map(nextJobs, function(job){
        return startJob(job, exercise, job.assessor)
      }).catch(function(err){
        console.log(err.stack)
      })

      /* ---------- ACTUAL BENCHMARK ENDS HERE ---------- */

      if(mode === 'avg'){
         yield wait( ~~expSample(lamda))
      }  
    }

  }catch(err){
    console.log(err.stack)
  }
  
  return result;
}
start = gen.lift(runGen);


//Main work starts here
var seedTimer = new Date;
mongooseFixtures.load(fixtures, db, dataLoaded);

/**
* Called when data from fixtures have loaded
* @param {Error} err Error (if there is one) that will be passed from mongooseFixtures
*/
function dataLoaded(err){
  if (err)  return console.log(err);
  console.log('Data loaded in %s ms', new Date - seedTimer);
  console.log('Using %s of memory', bytesToSize(process.memoryUsage().heapUsed));
 
  start().then(function(){
    console.log("Answer submissions have ended")
    console.log('after Answer submissions have ended: Using %s of memory', bytesToSize(process.memoryUsage().heapUsed));
  });
}

/**
* Submits an assessment job and searches for the next one for the specified asssessor
* @param {AssessmentJob} job The job to submit
* @param {Exercise} exercise The exercise the job is for
* @param {WhitelistEntry} assessor Assessor of the assessment job
*/
function submitJob(job, exercise, assessor){
  job.status = "finished";
  job.save(function(err, saved){
    if(err) throw err;
    console.log('Submitted assessment #%d for user',
      jobCounters[assessor._id], assessor.screenName);

    //we're going for the next job
    jobCounters[assessor._id]++;

    if(++totalCounter == totalAssessments){
      console.log('Assessment submissions have ended');
      console.log('Before exit process is using %s of memory', bytesToSize(process.memoryUsage().heapUsed));
      process.exit();
    }

    var start =  start = new Date;

    assManager.getNextAssessmentJob(job.session, exercise, assessor)
      .then(function(nextJob){
         console.log("Searched for assessment #%d in %d ms for \
user %s", jobCounters[assessor._id] , (new Date - start), assessor.screenName);
        startJob(nextJob, exercise, assessor)
      })
      .catch(function(err){
        console.log(err);
      })

  });
}


/**
* Utility function to prettify bytes
* @param {Number} bytes Bytes to prettify
* @returns {String} Input bytes in prettified format
*/
function bytesToSize(bytes) {
   if(bytes == 0) return '0 Byte';
   var k = 1000;
   var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
   var i = Math.floor(Math.log(bytes) / Math.log(k));
   return (bytes / Math.pow(k, i)).toPrecision(3) + ' ' + sizes[i];
}

/**
* Exponential distribution sampler. Can be used to generate random timings for a poisson process
* @param {Number} lamda The lamda of the exponential distribution
* @returns {Number} The time of the next sample
*/
function expSample(lamda){
  return - Math.log(1- Math.random())/lamda;
}

/**
* Waits the specified amount of miliseconds
* @param {Interger} val The amount of milliseconds to wait before resolving the promise
* @returns {Promise} A promise that will fulfill with true the val milliseconds have elapsed
*/
function wait(val){
  var deferred = when.defer();
  setTimeout(function(){
    deferred.resolve(true)
  }, val)
  return deferred.promise;
}
